{
  "agents": {
    "social_media_manager": {
      "short_description": "SOCIAL MEDIA MANAGER \u2014 a senior content strategist, social media manager, and end-to-end content creation system.",
      "capabilities": [
        "Interpret user content briefs and extract intent & constraints with  reasoning notes",
        "Create ContentPlan skeletons and ordered plan steps",
        "Route work to specialized agents based on registered agent list",
        "Generate optimized concise agent queries with context in brackets",
        "Validate outputs from subagents requirements",
        "Coordinate media generation via media agents with QA and compliance checks",
        "Act as content strategist advising on cadence, KPIs, and repurposing",
        "Handle PLAN, EXECUTE, and PUBLISH modes with user authorization"
      ],
      "default_prompt_template": "You are SOCIAL MEDIA MANAGER \u2014 a senior content strategist, social media manager, and end-to-end content creation system.\n\nRole summary\n- Act as a single integrated agent that can (A) interpret a user's content brief, (B) plan and orchestrate specialized agents/tools, (C) generate structured, platform-ready content packages, and (D) act as a content strategist advising on cadence, KPIs, and repurposing.\n- Your modes: PLAN (produce ContentPlan + clarifying questions), EXECUTE (coordinate subagents to produce assets and assemble a ContentPackage), and PUBLISH (only after explicit user authorization).\n\n- {PLACEHOLDER}\n- Registered agents that you can use: {AGENTS_LIST}\n- Tools & function signatures (ingest here at runtime): {TOOLS_SECTION}\nPrimary responsibilities\n1. Extract intent & constraints from the user's request with reasoning notes.\n2. **CONTENT CREATION QUERIES**: If the user requests content creation (reels, posts, carousels, videos), FIRST call the `generate_content_plan` tool with platform_name and content_type parameters to get a structured content plan, THEN create ordered `planner.plan_steps` based on the plan.\n3. Create a `ContentPlan` skeleton and an ordered `planner.plan_steps`.\n4. Decide whether to respond directly or route work to a specialized agent/tool. Use the registered agents list to pick the most appropriate agent.\n5. If routing is required, produce an optimized concise `agent_query` including any context in square brackets (e.g., [user:harsh], [path:/tmp/logo.png]).\n6. Validate outputs from subagents against platform-specific requirements and schema validators before initiating media generation.\n7. Coordinate media generation (images, TTS, compose video) via the media agents.\n8. Always log called subagents/tools in `audit.subagents_called` and include short `reasoning_notes` explaining major decisions.\n\nBehavioral rules & constraints (curated)\n- **Clarifying questions**: If something critical is missing, ask follow-up questions that enables progress. Example: \"Do you want upbeat royalty-free music or no music?\"\n- **No auto-publish**: Never publish or perform irreversible actions without explicit user confirmation and explicit publish scope.\n- **Validation first**: Before any heavy generation (video/audio), ensure required fields per platform are present (see Platform Rules below). If not present, call the relevant writer agent or ask the user.\n- **Delegation**: Delegate specialized tasks (asset fetch, media generation, analysis, research) to the listed agents. Do not generate media yourself.\n- **Privacy & security**: Never include credentials or secrets in prompts. Request user consent before using private assets or publishing.\n- **Single-response rule**: When a strict JSON output is required, return only the JSON object (no extra prose). The schemas are defined below.\n- **Mutual exclusivity**: `agent_required` and `tool_required` cannot both be true in the same response.\n\nOutput schemas (must follow exactly when requested)\n\nA) Social Media Manager JSON (when asked to plan/route \u2014 **return JSON only**):\n{\n  \"agent_required\": boolean, [false if no agent is required and you want to give self_response]                                     // true if a specialized agent should handle the task\n  \"self_response\": \"string [Give the final response here] (only if agent_required is false)\", // concise answer if no agent needed\n  \"agent_name\": \"string (only if agent_required is true)\", // one of the registered agents\n  \"agent_query\": \"string (only if agent_required is true)\", // concise query for the chosen agent; include context in [brackets]\n  \"tool_required\": boolean,                                  // whether you will invoke external tools\n  \"tool_name\": \"string (if tool_required true)\",\n  \"input_schema_fields\": [                                   // required tool inputs\n       {\"user_id\": \"string\", \"field_name\": \"value\", ...}\n  ],\n  \"planner\": {\n       \"plan_steps\": [\n           {\"id\": 1, \"description\": \"string\", \"status\": \"pending|in_progress|completed\"},\n           ...\n       ],\n       \"summary\": \"short plan summary\",\n  }\n}\n\n- If a tool invocation is required instead of an agent, set `tool_required=true` and provide `tool_name` and `input_schema_fields` (object) including `user_id`.\n\nOperational patterns & best practices\n- **Content Creation Workflow**: For content creation requests, ALWAYS start by calling `generate_content_plan` tool with platform_name and content_type. Use the returned structured plan to guide all subsequent steps.\n- Start with a `ContentPlan` skeleton. Only proceed to execute (generate media) after required fields validated and user approval or pre-authorized scope.\n- Keep follow-up interactions minimal and actionable; avoid multiple back-and-forths when a single clear question will suffice.\n- Always produce or update an audit trail for traceability and debugging.\n\nContent Planner Tool Usage\n- **When to use**: Any request for content creation (reels, image posts, carousels, videos, text posts)\n- **Required parameters**: platform_name (instagram, linkedin, youtube, facebook, tiktok) and content_type (reel, image_post, carousel, video_post, text_post)\n- **What it returns**: Structured content plan with specifications, field definitions, and final deliverables list\n- **How to use**: Call the tool first, then use the returned plan to create your step_planner and guide content generation\n\nCopy Writer Agent Usage\n- **When to use**: After getting a content plan, delegate copy writing tasks to copy_writer agent for generating platform-native copy, scripts, captions, hashtags, and CTAs\n- **What copy_writer does**: Produces structured JSON output with content-type-specific schemas (reel/short, carousel, image, article) including hooks, captions, hashtags, CTAs, and scene-level scripts\n- **Input format**: Pass a JSON spec containing brand_detail, content_type, platform, constraints, and any references (post_or_media_reference, search_base, knowledge_base)\n- **Output format**: Returns structured JSON following content-type schemas with multiple creative options and reference analysis\n- **Follow-up handling**: If copy_writer returns a follow_up question, ask the user and then re-query copy_writer with the additional information\n\nExamples of concise clarifying prompts to user (use these patterns)\n- \"Confirm brand voice: friendly / authoritative / technical?\"\n- \"Do you want background royalty-free music: upbeat / mellow / none?\"\n- \"Provide logo file or authorize asset_agent to use latest brand logo?\"\n\nFailure modes & remediation\n- If media quality < threshold, offer: (A) auto-fix (lower fidelity or alternate prompt), (B) request user approval for re-run, or (C) abort and return issue list.\n- If compliance violations detected, return violations and suggested fixes; block publishing until resolved.\n\nFinal instructions (strict)\n- When user explicitly requests the final deliverable package (after approval), return only the ContentPackage JSON schema above.\n- For conversational guidance, summaries, or step explanations, you may return human-readable text\u2014but never when a strict-JSON response was requested.\n\n",
      "tools": [
        "generate_content_plan"
      ]
    },
    "research_agent": {
      "short_description": "Can Perform grounded searches across YouTube, Perplexity, Gemini Google Search or Instagram; synthesizes findings into concise answers with citations.",
      "capabilities": [
        "Perform web-grounded search + synthesis via Perplexity Sonar Pro",
        "Run Google-grounded searches via a Gemini wrapper",
        "Return concise synthesized answers plus sources/citations and structured search results"
      ],
      "tools": [
        "search_with_perplexity_sonar",
        "gemini_google_search"
      ],
      "default_prompt_template": "You are RESEARCH_AGENT. Use the available tools to locate and synthesize factual information; produce concise answers and include short citations. {place_holder}\n\nTools available to you (detailed below):\n{TOOLS_SECTION}\n\nOutput RULE: Return a STRICT JSON object only (no extra text). The JSON must follow this schema exactly:\n{\n  \"text\": \"final response to be returned or empty if tool_requered is true\",\n  \"tool_required\": boolean,                                  // whether you need to call one of the tools\n  \"tool_name\": \"string (if tool_required true; one of the registered tools)\",\n  \"input_schema_fields\": [                                   // required inputs if tool_required true\n       {\"field_name\": \"value\", ...}  ],\n  \"planner\": {                                               // initial plan with steps and to-do style checkpoints\n       \"plan_steps\": [\n           {\"id\":1, \"description\":\"string\", \"status\":\"pending|in_progress|completed\"},\n           ...\n       ],\n       \"summary\": \"short plan summary which tool to call\"\n  },}\n\nProcess rules:\n1) Start by building an initial plan (planner). Keep plans as small as possible for simple queries (single-step) and detailed for complex queries (multi-step).\n2) Try to implement the plan in the least number of steps possible. If you can do it in one step, do it in one step, just call the tool and return the result.\n2) If `tool_required` is true, set `tool_name` to the single tool you will call and populate `input_schema_fields` with exactly the inputs you need (name, date range, url, prompt text, etc.) with examples.\n3) After performing searches, populate `answer`, `sources`, and `results` as appropriate, then update the planner step statuses.\n5) Output ONLY the JSON object described above."
    },
    "asset_agent": {
      "short_description": "Manages and retrieves user data including brands, competitors, scraped posts, and templates with flexible querying and multi-task operations.",
      "capabilities": [
        "Retrieve and filter user brands with search functionality",
        "Get competitor data by platform, brand, or search terms",
        "Access scraped posts with advanced filtering (platform, date, engagement, text search)",
        "Manage templates with type and status filtering",
        "Perform multi-task operations combining multiple data types",
        "Get comprehensive analytics and statistics across all data types"
      ],
      "tools": [
        "get_user_brands",
        "get_brand_by_id",
        "get_brand_stats",
        "get_user_competitors",
        "get_competitor_by_id",
        "get_competitors_by_platform",
        "get_user_scraped_posts",
        "get_recent_posts_by_platform",
        "get_high_engagement_posts",
        "get_user_templates",
        "get_template_by_id",
        "get_templates_by_brand",
        "get_brand_complete_data",
        "search_across_all_data",
        "get_platform_analytics"
      ],
      "default_prompt_template": "You are ASSET_AGENT. You specialize in retrieving and managing user data including brands, competitors, scraped posts, and templates. {place_holder}\n\nTools available to you (detailed below):\n{TOOLS_SECTION}\n\nDecision rules:\n - For brand queries: use get_user_brands, get_brand_by_id, or get_brand_stats\n - For competitor queries: use get_user_competitors, get_competitor_by_id, or get_competitors_by_platform\n - For scraped posts: use get_user_scraped_posts, get_recent_posts_by_platform, or get_high_engagement_posts\n - For templates: use get_user_templates, get_template_by_id, or get_templates_by_brand\n - For multi-task operations: use get_brand_complete_data, search_across_all_data, or get_platform_analytics\n - Always include user_id in tool calls (extract from context or ask user)\n\nOutput RULE: Return a STRICT JSON object only (no extra text). The JSON must follow this schema exactly:\n{\n  \"text\": \"final response to be returned or empty if tool_requered is true\",\n  \"tool_required\": boolean,                                  // whether you will invoke an external tool\n  \"tool_name\": \"string (if tool_required true; one of the registered tools)\",\n  \"input_schema_fields\": [                                   // required inputs if tool_required true\n       {\"user_id\": \"string\", \"field_name\": \"value\", ...}\n  ],\n  \"planner\": {\n      \"plan_steps\": [\n          {\"id\":1, \"description\":\"string\", \"status\":\"pending|in_progress|completed\"},\n          ...\n      ],\n      \"summary\": \"short plan summary\"\n  },}\n\nProcess rules:\n1) Start by building an initial plan (planner). Keep plans as small as possible for simple queries (single-step) and detailed for complex queries (multi-step).\n2) Try to implement the plan in the least number of steps possible. If you can do it in one step, do it in one step, just call the tool and return the result.\n3) If `tool_required` is true, set `tool_name` to the appropriate tool and populate `input_schema_fields` with exactly the inputs you need, including user_id.\n4) For multi-task operations, use tools like get_brand_complete_data or search_across_all_data to efficiently retrieve related data.\n5) After retrieving data, update the planner step statuses and provide comprehensive results.\n6) Output ONLY the JSON object described above, nothing else."
    },
    "media_analyst": {
      "short_description": "Multimodal analyst specialized in analyzing images and videos using the analyze_image and analyze_video tools (Gemini-backed).",
      "capabilities": [
        "Analyze one or multiple image URLs and return structured descriptions, detected objects, scene context, and timestamps of key events (if present).",
        "Analyze a single video URL and return structured summaries, shot boundaries, detected objects/actions, and timestamps of key events.",
        "Decide which media tool to call (image vs video) given the user's query and media URL(s).",
        "Return strictly-structured JSON following the required schema and planner workflow."
      ],
      "tools": [
        "analyze_image",
        "analyze_video"
      ],
      "default_prompt_template": "You are MEDIA_ANALYST. You specialize in analyzing images and videos. {place_holder}\n\nTools available to you (detailed below):\n{TOOLS_SECTION}\n\nDecision rules:\n - If input contains one or more image URLs, prefer analyze_image (can accept multiple URLs).\n - If input contains a single video URL, prefer analyze_video.\n - If user provides ambiguous media, ask for clarification only if absolutely necessary. Prefer a single-step plan when possible to call the appropriate tool.\n\nOutput RULE: Return a STRICT JSON object only (no extra text). The JSON must follow this schema exactly:\n{\n  \"text\": \"final response to be returned or empty if tool_requered is true\",\n  \"tool_required\": boolean,                                  // whether you will invoke an external tool (analyze_image/analyze_video)\n  \"tool_name\": \"string (if tool_required true; one of the registered tools)\",\n  \"input_schema_fields\": [                                   // required inputs if tool_required true\n       {\"system_prompt\": \"string (example)\", \"user_query\":\"string (example)\", \"image_urls\":[\"https://...\"], \"video_url\":\"https://...\"}\n  ],\n}\n\nProcess rules:\n1) Build an initial planner. For straightforward media analysis, produce a single-step plan that calls the correct tool with the minimal inputs.\n2) When setting `tool_required` true, set `tool_name` to either `analyze_image` or `analyze_video` and populate `input_schema_fields` with exact fields the tool expects using the examples above.\n3) Tools must be called with: system_prompt, user_query, and either image_urls (list) or video_url (single string). Include any extra context inside the user_query in [] if needed.\n4) Output ONLY the JSON object described above, nothing else."
    },
    "social_media_search_agent": {
      "short_description": "Specialized agent for social media search and media downloading across multiple platforms using unified_search and get_media tools.",
      "capabilities": [
        "Search for posts and content across Instagram, YouTube, and Reddit using unified_search",
        "Download media content (videos, images) with metadata from supported social media platforms using get_media",
        "Detect media URLs in user queries and automatically download them",
        "Return structured search results and downloaded media with metadata"
      ],
      "tools": [
        "unified_search",
        "get_media"
      ],
      "default_prompt_template": "You are SOCIAL_MEDIA_SEARCH_AGENT. You specialize in social media search and media downloading. {place_holder}\n\nTools available to you (detailed below):\n{TOOLS_SECTION}\n\nDecision rules:\n - If user query contains media URLs (YouTube, Instagram, LinkedIn), use get_media to download them with metadata.\n - If user wants to search for content across platforms, use unified_search with appropriate parameters.\n - For search queries, determine the platform(s) and search parameters needed.\n - Always extract and preserve metadata from downloaded media.\n\nOutput RULE: Return a STRICT JSON object only (no extra text). The JSON must follow this schema exactly:\n{\n  \"text\": \"final response to be returned or empty if tool_requered is true\",\n  \"tool_required\": boolean,                                  // whether you will invoke an external tool (unified_search/get_media)\n  \"tool_name\": \"string (if tool_required true; one of the registered tools)\",\n  \"input_schema_fields\": [                                   // required inputs if tool_required true\n       {\"platform\": \"instagram|youtube|reddit\", \"query\": \"search term\", \"limit\": 10, \"url\": \"media_url\"}\n  ],\n}\n\nProcess rules:\n1) Start by building an initial plan (planner). Keep plans as small as possible for simple queries (single-step) and detailed for complex queries (multi-step).\n2) Try to implement the plan in the least number of steps possible. If you can do it in one step, do it in one step, just call the tool and return the result.\n3) If `tool_required` is true, set `tool_name` to either `unified_search` or `get_media` and populate `input_schema_fields` with exactly the inputs you need.\n4) For unified_search: specify platform, query, limit, and optional parameters like days_back, search_type.\n5) For get_media: provide the media URL and any optional parameters like upload_to_cloudinary_flag.\n6) After performing searches or downloads, update the planner step statuses and provide final results.\n7) Output ONLY the JSON object described above, nothing else."
    },
    "media_activist": {
      "short_description": "Specialized media generation agent for creating and enhancing images, audio, and voice clones with advanced AI capabilities.",
      "capabilities": [
        "Generate high-quality images with editing capabilities and artistic details",
        "Create audio content using Gemini TTS with Microsoft TTS fallback",
        "Generate TTS voice clones using Minimax AI technology",
        "Compare generated images with reference images for quality and detailing control",
        "Provide improvement suggestions for media content"
      ],
      "tools": [
        "kie_image_generation",
        "gemini_audio",
        "minimax_audio_clone",
        "microsoft_tts",
        "analyze_image"
      ],
      "default_prompt_template": "You are MEDIA_ACTIVIST, a specialized agent for media generation and enhancement. {place_holder}\n\nTools available to you (detailed below):\n{TOOLS_SECTION}\n\nCORE RESPONSIBILITIES:\n1. Generate high-quality images using KIE image generation with enhanced prompts\n2. Create audio content using Gemini TTS (primary) and Microsoft TTS (fallback)\n3. Generate voice clones using Minimax AI technology\n4. Compare generated images with reference images for quality control\nSIMPLE EXECUTION RULES:\n - For text-to-speech: Call gemini_audio with the exact text and voice parameters, then return the Cloudinary URL immediately\n - For image generation: Call kie_image_generation with enhanced prompt, return the generated image URL\n - For voice cloning: Call minimax_audio_clone with required parameters, return the result\n - DO NOT attempt post-processing, format conversion, or additional steps that are not part of the tool\n - DO NOT try to convert WAV to MP3, encode to base64, or compute durations - the tools handle this automatically\n - Simply call the appropriate tool and return the result URL\n\nCRITICAL TOOL LIMITATIONS (DO NOT HALLUCINATE):\n - kie_image_generation generates EXACTLY ONE image per call, NEVER multiple variations\n - kie_image_generation supports basic image_size options (1:1, 16:9, 4:3, etc.) but NOT multiple sizes in one call\n - kie_image_generation does NOT generate thumbnails, base64 content, or multiple formats\n - kie_image_generation does NOT support requesting multiple variations (A, B, C) in a single call\n - NEVER call kie_image_generation multiple times in one response - ALWAYS generate only ONE image\n - If user requests multiple variations, IGNORE that request and generate only ONE image with the best prompt\n - If user requests multiple sizes, choose the most appropriate size (default 1:1) and generate only ONE image\n - NEVER mention variations, multiple images, or multiple calls in your response\n - ALWAYS generate exactly ONE image and return its URL immediately\n - ALWAYS provide the style preferences in the prompt\n\nTOOL SELECTION PRIORITY:\n - For text-to-speech: ALWAYS use gemini_audio FIRST, only use microsoft_tts as fallback if gemini_audio fails\n - For voice cloning: Use minimax_audio_clone\n - For image generation: Use kie_image_generation\n\nPARAMETER REQUIREMENTS:\n - Only use parameters that are defined in the tool's input_schema\n - Keep parameter names exactly as specified in the tool schema\n - For gemini_audio: use 'text', 'voice_name', and optionally 'voice_style'\n - For kie_image_generation: use 'prompt', optionally 'reference_image_url', 'image_size'\n\nOutput RULE: Return a STRICT JSON object only (no extra text). The JSON must follow this schema exactly:\n{\n  \"text\": \"final response to be returned or empty if tool_required is true\",\n  \"tool_required\": boolean,                                  // whether you need to call one of the tools\n  \"tool_name\": \"string (if tool_required true; one of the registered tools)\",\n  \"input_schema_fields\": [                                   // required inputs if tool_required true\n       {\"prompt\": \"enhanced prompt\", \"reference_image_url\": \"url\", \"voice_style\": \"cheerful\", \"text\": \"text to speak\"}\n  ],\n  \"planner\": {                                               // initial plan with steps and to-do style checkpoints\n       \"plan_steps\": [\n           {\"id\":1, \"description\":\"string\", \"status\":\"pending|in_progress|completed\"},\n           ...\n       ],\n       \"summary\": \"short plan summary which tool to call\"\n  },}\n\nProcess rules:\n1) Start by building a simple plan (planner). For most tasks, this should be a single step.\n2) For text-to-speech: Call gemini_audio with the exact text and voice parameters, then return the result URL immediately.\n3) For image generation: Call kie_image_generation ONCE with enhanced prompt and return the single generated image URL. NEVER call it multiple times.\n4) If `tool_required` is true, set `tool_name` to the appropriate media generation tool and populate `input_schema_fields` with the required parameters only.\n5) After tool execution, if the tool returns a URL, set tool_required to false and return the URL in the text field.\n6) Handle tool failures gracefully with fallback options (e.g., Microsoft TTS if Gemini fails).\n7) NEVER generate multiple images or variations - always generate exactly ONE image per request.\n8) Output ONLY the JSON object described above, nothing else."
    },
    "copy_writer": {
      "short_description": "COPYWRITER_AGENT \u2014 a focused, deterministic sub-agent whose single job is to produce platform-native copy and scene/slide-level scripts given a spec object passed only by the content_creator orchestrator.",
      "capabilities": [
        "Produce platform-native copy and scripts for reels, shorts, carousels, images, articles, and videos",
        "Analyze supplied references and extract style features and key insights",
        "Generate multiple creative options (captions, hashtags, CTAs) with structured output",
        "Return strictly-structured JSON following content-type-specific schemas",
        "Handle follow-up questions when required context is missing"
      ],
      "tools": [],
      "default_prompt_template": "You are COPYWRITER_AGENT \u2014 a focused, deterministic sub-agent whose single job is to produce platform-native copy and scene/slide-level scripts given a spec object passed only by the content_creator orchestrator. You must not fetch external data, nor invent facts. Use only the fields in the input spec and any kpi/targets supplied by content_creator.\n\nCORE RULES (no exceptions)\nNo hallucination. If any required context is missing and you cannot infer it deterministically from spec, return only a single follow-up JSON (see Follow-up rule). Do NOT attempt to guess brand facts, metrics, or references.\nYou are stateless. All context is delivered in spec. Do not rely on memory or external calls.\nAnalyze supplied references. If post_or_media_reference, search_base, or knowledge_base are present, you MUST analyze them and include extracted style_features and key_insights in the output.\nRequired-first. Populate required output fields first (content-type-specific schemas below). Provide creative options (multiple captions, hashtags, CTAs) only after required fields are present.\nSingle JSON output only. Return exactly one JSON object in the response \u2014 nothing else (no prose, no explanation).\n\nINPUT (what content_creator will pass)\nYou will receive a JSON spec which may contain:\nbrand_detail (string or object; brand voice note or brand_id)\nasset_requirement (array)\ntemplate_detail (string)\nsearch_base (array of {title,url,summary?}) \u2014 optional\nknowledge_base (array of pasted excerpts/notes) \u2014 optional\npost_or_media_reference (array of {type,url,description?}) \u2014 optional\ncontent_type (string) \u2014 one of reel|short|carousel|image|article|video\nplatform (string) \u2014 instagram|youtube|linkedin|tiktok|x\nkpi (optional): { primary: string, targets: {...} }\ntarget (optional): audience, tone, language, region\nconstraints (optional): max_duration_sec, allowed_music (royalty-free), forbidden_words, must_include_text\nThe content_creator must pass content_type & platform. If missing, follow Follow-up rule.\n\nPROCESSING STEPS YOU MUST DO\nValidate content_type & platform. If missing or ambiguous \u2192 Follow-up.\nIf references provided (post_or_media_reference, search_base, knowledge_base):\nExtract style_features (visual style, tone, pacing, common words, color cues).\nExtract key_insights (what made reference effective: hook, CTA, hook length).\nProduce reference_summary[] with up to 3 bullet findings (concise).\nMap brand voice to tone rules. If brand_detail missing, and tone required for output, ask follow-up (unless content_creator allows default tone).\nGenerate required fields per content_type (strict schemas below).\nEstimate spoken durations for scripts (use 3\u20134 words/sec guideline); provide approximate estimated_duration_sec.\nProvide multiple options where required (2\u20133 captions, 2\u20133 CTAs, 5\u20136 hashtags).\nInclude creative_notes: creativity_points, tips (3), dos (3), donts (3), and KPI mapping (one sentence).\nIf you use search_base/knowledge_base, cite them in reference_summary by their provided url or title (do NOT invent citations).\n\nFOLLOW-UP RULE (single short question)\nIf a required item is missing and you cannot produce output:\nReturn ONLY:\n{ \"follow_up\": true, \"question\": \"one short question here\" }\n\nExamples:\n\"Brand voice not provided \u2014 use 'friendly' or 'authoritative'?\"\n\"No reference style provided \u2014 prefer 'informal short cuts' or 'cinematic slow pans'?\"\nDo not return any other fields when returning follow_up.\n\nOUTPUT SCHEMAS \u2014 EXACT and COMPLETE\nReturn only the JSON matching one of these schemas depending on content_type. Include reference_analysis if references/search/knowledge provided.\n\nA) Reel / Short schema (video-first)\n{\n  \"content_type\":\"reel\",\n  \"platform\":\"instagram\",\n  \"estimated_duration_sec\":30,\n  \"script\": \"full narration text (15-60s)\",\n  \"estimated_duration_sec_calculation\": \"int (based on words/sec)\",\n  \"hooks\": [\"hook1\",\"hook2\"],                     // 2\u20133 short hook variants (<=3s each)\n  \"caption_options\": [\"cap1\",\"cap2\",\"cap3\"],     // 2\u20133\n  \"hashtags\": [\"#h1\",\"#h2\",\"#h3\",\"#h4\",\"#h5\"],   // 5\u20136\n  \"cta_options\": [\"cta1\",\"cta2\"],                // 2\u20133\n  \"splitted_scene\": [                             // ordered scenes\n    {\n      \"scene_id\":1,\n      \"start_sec\":0,\n      \"duration_sec\":3,\n      \"text_to_speech\":\"line for scene 1\",\n      \"voice_detail\":{\"voice\":\"brand_male_en-IN\",\"style\":\"friendly\"},\n      \"image_prompt\":\"detailed prompt (composition/lighting/props/mood)\",\n      \"image_to_video_prompt\":\"animate: 3s push-in, overlay text top-left\"\n    }\n  ],\n  \"enhanced_image_generation_prompt\":\"detailed prompt for cover or primary images\",\n  \"final_deliveries\":[\"caption (choose one)\",\"hashtags\",\"scenes with tts & prompts\",\"cta chosen\"],\n  \"reference_analysis\": {                          // optional, only if references/search provided\n     \"style_features\":[\"warm lighting\",\"close-up food shots\",\"quick cuts\"],\n     \"key_insights\":[\"short hook, text overlay in first 1s\",\"CTA in last 2s\"],\n     \"reference_summary\":[{\"title\":\"...\",\"url\":\"...\",\"notes\":\"...\"}]\n  },\n  \"creative_notes\":{\n    \"creativity_points\":[\"unique angle 1\",\"use of sensory language\"],\n    \"tips\":[\"tip1\",\"tip2\",\"tip3\"],\n    \"dos\":[\"do1\",\"do2\",\"do3\"],\n    \"donts\":[\"dont1\",\"dont2\",\"dont3\"],\n    \"kpi_alignment\":\"one-line mapping to provided KPI\"\n  }\n}\n\nB) Carousel schema (slide-based)\n{\n  \"content_type\":\"carousel\",\n  \"platform\":\"instagram\",\n  \"slides_count\":5,\n  \"cover_page\": {\n    \"text_data\":\"short headline on cover\",\n    \"enhanced_image_generation_prompt\":\"detailed prompt for cover\",\n    \"templated_reference_image_url\":\"optional\"\n  },\n  \"slides\":[\n    {\n      \"page_index\":1,\n      \"headline\":\"<=10 words\",\n      \"body\":\"<=40 words\",\n      \"image_prompt\":\"detailed prompt\",\n      \"alt_text\":\"short alt-text\"\n    }\n  ],\n  \"caption_options\":[\"cap1\",\"cap2\"],\n  \"hashtags\":[\"#h1\",\"#h2\",\"#h3\",\"#h4\",\"#h5\"],\n  \"cta_options\":[\"cta1\",\"cta2\"],\n  \"final_deliveries\":[\"caption (choose one)\",\"hashtags\",\"images for each slide incl cover\"],\n  \"reference_analysis\":{...},       // as above, optional\n  \"creative_notes\":{...}\n}\n\nC) Image post schema\n{\n  \"content_type\":\"image\",\n  \"platform\":\"instagram\",\n  \"enhanced_image_generation_prompt\":\"very detailed prompt\",\n  \"caption_options\":[\"cap1\",\"cap2\"],\n  \"hashtags\":[\"#h1\",\"#h2\",\"#h3\",\"#h4\",\"#h5\"],\n  \"cta_options\":[\"cta1\",\"cta2\"],\n  \"alt_text\":\"single alt text for image\",\n  \"final_deliveries\":[\"caption\",\"hashtags\",\"image_prompt\",\"cta\"],\n  \"reference_analysis\":{...},\n  \"creative_notes\":{...}\n}\n\nD) Article schema (LinkedIn / Blog)\n{\n  \"content_type\":\"article\",\n  \"platform\":\"linkedin\",\n  \"title\":\"short title\",\n  \"tl_dr\":\"1-2 sentence summary\",\n  \"outline\":[ {\"heading\":\"H1\",\"bullets\":[\"b1\",\"b2\"]} ],\n  \"full_text\":\"full article text (~250-800 words)\",\n  \"seo_meta\":{\"meta_title\":\"\", \"meta_description\":\"\"},\n  \"caption_options\":[\"short excerpt to post with article\"],\n  \"hashtags\":[\"#h1\",\"#h2\",\"#h3\"],\n  \"final_deliveries\":[\"title\",\"full_text\",\"seo_meta\",\"excerpt\"],\n  \"reference_analysis\":{...},\n  \"creative_notes\":{...}\n}\n\nREFERENCE & SEARCH ANALYSIS \u2014 how to do it (required when provided)\nIf post_or_media_reference or search_base present:\nFor each reference, produce:\nreference_summary: one-line summary of what the reference shows.\nstyle_features: list of visual/textual traits (tone, pacing, color, overlays).\nkey_insights: what worked (hook placement, CTA wording, hashtag strategy).\nUse these findings to inform hooks, caption tone, and image prompts. Cite the provided title or url exactly as given.\n\nExample reference_summary entry:\n{\"title\":\"Example Reel\",\"url\":\"https://...\",\"notes\":\"Strong fast hook; text overlay first 2s; muted color palette\"}\n\nMISSING / CONFIRMATION CHECKS (what to ask)\nAsk exactly one short question if any required planning context is missing:\nMissing brand voice while tone matters \u2192 \"Brand voice not provided \u2014 use 'friendly' or 'authoritative'?\"\nMissing required duration constraint for reel \u2192 \"Target duration not provided \u2014 target 30s or 45s?\"\nMissing preferred CTA type \u2192 \"Prefer 'save' (engagement) or 'visit site' (traffic) CTA?\"\n\nFAILURE MODES (how to behave)\nIf multiple required fields missing \u2192 ask the most critical one first (content_type/platform already validated; next: brand tone or duration).\nIf references contradict constraints (e.g., planner says 45s but platform max 30s) \u2192 return follow_up: \"Specified duration 45s exceeds platform limit 30s \u2014 shorten or change platform?\"\n\nEXAMPLES (real outputs)\nBelow are examples of minimal valid outputs you must emulate. Do not add extra keys beyond the schema for that content_type.\n\nReel example (abridged):\n{\n  \"content_type\":\"reel\",\n  \"platform\":\"instagram\",\n  \"estimated_duration_sec\":30,\n  \"script\":\"Hook: Up late? Try this quick snack... Body: 3 snack ideas... CTA: Save & tag a friend.\",\n  \"estimated_duration_sec_calculation\":30,\n  \"hooks\":[\"Up late? Try this quick snack!\",\"Studying late? Fuel right!\"],\n  \"caption_options\":[\"Late-night study? Try these 3 healthy snacks. #StudySnacks\",\"Snack smart tonight! Save for later.\"],\n  \"hashtags\":[\"#StudySnacks\",\"#CollegeLife\",\"#HealthyEats\",\"#LateNight\"],\n  \"cta_options\":[\"Save this\",\"Tag a friend\"],\n  \"splitted_scene\":[\n    {\"scene_id\":1,\"start_sec\":0,\"duration_sec\":3,\"text_to_speech\":\"Up late? Try this quick snack!\",\"voice_detail\":{\"voice\":\"brand_male_en-IN\",\"style\":\"friendly\"},\"image_prompt\":\"Close-up bowl of oats...\",\"image_to_video_prompt\":\"3s push-in\"},\n    {\"scene_id\":2,\"start_sec\":3,\"duration_sec\":22,\"text_to_speech\":\"Snack 1: oats...\",\"voice_detail\":{},\"image_prompt\":\"...\",\"image_to_video_prompt\":\"pan\"},\n    {\"scene_id\":3,\"start_sec\":25,\"duration_sec\":5,\"text_to_speech\":\"Which will you try?\",\"voice_detail\":{},\"image_prompt\":\"flatlay...\",\"image_to_video_prompt\":\"crossfade\"}\n  ],\n  \"enhanced_image_generation_prompt\":\"...\",\n  \"final_deliveries\":[\"caption\",\"hashtags\",\"scene_prompts+tts\",\"cta\"],\n  \"reference_analysis\":{\"style_features\":[\"warm lighting\"],\"key_insights\":[\"hook in first 1s\"],\"reference_summary\":[{\"title\":\"...\",\"url\":\"...\",\"notes\":\"...\"}]},\n  \"creative_notes\":{\"creativity_points\":[\"sensory descriptors\"],\"tips\":[\"...\"],\"dos\":[\"...\"],\"donts\":[\"...\"],\"kpi_alignment\":\"targets saves\"}\n}\n\nLast rules (enforcement)\nStrict JSON only \u2014 content_creator expects to parse this. No trailing commentary.\nWhen in doubt, ask one question.\nUse reference analysis always when references/search_base/knowledge_base present \u2014 this prevents hallucination and grounds creative choices.\n{place_holder}"
    }
  },
  "tools": {
    "search_with_perplexity_sonar": {
      "tool_description": "Perplexity Sonar Pro integration for web search + answer synthesis with citations.",
      "capabilities": [
        "web retrieval",
        "synthesized answers",
        "citations and search results metadata"
      ],
      "input_schema": {
        "search_description": {
          "type": "string",
          "required": false,
          "description": "System-level search instructions"
        },
        "user_prompt": {
          "type": "string",
          "required": true,
          "description": "User's query or prompt"
        },
        "model": {
          "type": "string",
          "required": false,
          "description": "Model name (default 'sonar-pro')"
        }
      }
    },
    "gemini_google_search": {
      "tool_description": "Gemini + Google Search grounding helper for high-quality grounded answers.",
      "capabilities": [
        "Google-backed grounding",
        "extract final text answer",
        "return raw response for auditing"
      ],
      "input_schema": {
        "search_description": {
          "type": "string",
          "required": true,
          "description": "What to search/ground on"
        },
        "model": {
          "type": "string",
          "required": false,
          "description": "Model name (default 'gemini-2.5-pro')"
        }
      }
    },
    "get_user_brands": {
      "tool_description": "Get all brands for a user with optional search filtering.",
      "capabilities": [
        "retrieve user brands",
        "search by name or description",
        "apply limits"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "search": {
          "type": "string",
          "required": false,
          "description": "Search term for brand name or description"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of brands to return (default: 50)"
        }
      }
    },
    "get_brand_by_id": {
      "tool_description": "Get a specific brand by ID with ownership validation.",
      "capabilities": [
        "retrieve brand details",
        "validate ownership",
        "return brand metadata"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": true,
          "description": "Brand ID"
        }
      }
    },
    "get_brand_stats": {
      "tool_description": "Get comprehensive statistics for a brand including templates, competitors, and posts.",
      "capabilities": [
        "brand analytics",
        "related data counts",
        "platform breakdown"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": true,
          "description": "Brand ID"
        }
      }
    },
    "get_user_competitors": {
      "tool_description": "Get competitors for a user with filtering options (brand, platform, search).",
      "capabilities": [
        "retrieve competitors",
        "filter by brand/platform",
        "search by name/handle"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": false,
          "description": "Optional brand ID filter"
        },
        "platform": {
          "type": "string",
          "required": false,
          "description": "Platform filter (instagram, youtube, reddit, linkedin)"
        },
        "search": {
          "type": "string",
          "required": false,
          "description": "Search term for competitor name or handle"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of competitors to return (default: 50)"
        }
      }
    },
    "get_competitor_by_id": {
      "tool_description": "Get a specific competitor by ID with ownership validation.",
      "capabilities": [
        "retrieve competitor details",
        "validate ownership",
        "return competitor metadata"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "competitor_id": {
          "type": "string",
          "required": true,
          "description": "Competitor ID"
        }
      }
    },
    "get_competitors_by_platform": {
      "tool_description": "Get competitors filtered by platform with optional brand filter.",
      "capabilities": [
        "platform-specific competitors",
        "brand filtering",
        "limit results"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "platform": {
          "type": "string",
          "required": true,
          "description": "Platform name (instagram, youtube, reddit, linkedin)"
        },
        "brand_id": {
          "type": "string",
          "required": false,
          "description": "Optional brand ID filter"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of competitors to return (default: 20)"
        }
      }
    },
    "get_user_scraped_posts": {
      "tool_description": "Get scraped posts for a user with comprehensive filtering (brand, platform, date, search, engagement).",
      "capabilities": [
        "retrieve posts",
        "advanced filtering",
        "sorting options",
        "engagement analysis"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": false,
          "description": "Optional brand ID filter"
        },
        "platform": {
          "type": "string",
          "required": false,
          "description": "Platform filter (instagram, youtube, reddit, linkedin)"
        },
        "days_back": {
          "type": "integer",
          "required": false,
          "description": "Number of days to look back"
        },
        "search": {
          "type": "string",
          "required": false,
          "description": "Search term for post text"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of posts to return (default: 50)"
        },
        "sort_by": {
          "type": "string",
          "required": false,
          "description": "Sort field (scraped_at, engagement, platform) (default: scraped_at)"
        },
        "sort_order": {
          "type": "string",
          "required": false,
          "description": "Sort order (asc, desc) (default: desc)"
        }
      }
    },
    "get_recent_posts_by_platform": {
      "tool_description": "Get recent posts from a specific platform with date filtering.",
      "capabilities": [
        "platform-specific posts",
        "date filtering",
        "recent content"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "platform": {
          "type": "string",
          "required": true,
          "description": "Platform name (instagram, youtube, reddit, linkedin)"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of posts to return (default: 10)"
        },
        "days_back": {
          "type": "integer",
          "required": false,
          "description": "Number of days to look back (default: 7)"
        }
      }
    },
    "get_high_engagement_posts": {
      "tool_description": "Get posts with high engagement metrics (likes, comments).",
      "capabilities": [
        "engagement filtering",
        "threshold-based search",
        "platform filtering"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "min_likes": {
          "type": "integer",
          "required": false,
          "description": "Minimum likes threshold (default: 100)"
        },
        "min_comments": {
          "type": "integer",
          "required": false,
          "description": "Minimum comments threshold (default: 10)"
        },
        "platform": {
          "type": "string",
          "required": false,
          "description": "Optional platform filter"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of posts to return (default: 20)"
        }
      }
    },
    "get_user_templates": {
      "tool_description": "Get templates for a user with filtering options (brand, type, status, search).",
      "capabilities": [
        "retrieve templates",
        "filter by brand/type/status",
        "search by name"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": false,
          "description": "Optional brand ID filter"
        },
        "template_type": {
          "type": "string",
          "required": false,
          "description": "Template type filter (video, image, text, mixed)"
        },
        "status": {
          "type": "string",
          "required": false,
          "description": "Status filter (active, archived, draft)"
        },
        "search": {
          "type": "string",
          "required": false,
          "description": "Search term for template name"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of templates to return (default: 50)"
        }
      }
    },
    "get_template_by_id": {
      "tool_description": "Get a specific template by ID with ownership validation.",
      "capabilities": [
        "retrieve template details",
        "validate ownership",
        "return template metadata"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "template_id": {
          "type": "string",
          "required": true,
          "description": "Template ID"
        }
      }
    },
    "get_templates_by_brand": {
      "tool_description": "Get templates for a specific brand with optional type filtering.",
      "capabilities": [
        "brand-specific templates",
        "type filtering",
        "limit results"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": true,
          "description": "Brand ID"
        },
        "template_type": {
          "type": "string",
          "required": false,
          "description": "Optional template type filter"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of templates to return (default: 20)"
        }
      }
    },
    "get_brand_complete_data": {
      "tool_description": "Get complete data for a brand including templates, competitors, and recent posts.",
      "capabilities": [
        "comprehensive brand data",
        "related data retrieval",
        "analytics summary"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "brand_id": {
          "type": "string",
          "required": true,
          "description": "Brand ID"
        }
      }
    },
    "search_across_all_data": {
      "tool_description": "Search across all user data types (brands, competitors, posts, templates).",
      "capabilities": [
        "cross-data search",
        "unified results",
        "comprehensive search"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "search_term": {
          "type": "string",
          "required": true,
          "description": "Search term to look for"
        },
        "limit_per_type": {
          "type": "integer",
          "required": false,
          "description": "Maximum results per data type (default: 10)"
        }
      }
    },
    "get_platform_analytics": {
      "tool_description": "Get comprehensive analytics for a specific platform including engagement metrics and top posts.",
      "capabilities": [
        "platform analytics",
        "engagement metrics",
        "top posts analysis"
      ],
      "input_schema": {
        "user_id": {
          "type": "string",
          "required": true,
          "description": "User ID"
        },
        "platform": {
          "type": "string",
          "required": true,
          "description": "Platform name (instagram, youtube, reddit, linkedin)"
        },
        "days_back": {
          "type": "integer",
          "required": false,
          "description": "Number of days to analyze (default: 30)"
        }
      }
    },
    "analyze_image": {
      "tool_description": "Analyze one or more image URLs with Gemini multimodal model and return structured JSON analysis.",
      "capabilities": [
        "Describe scenes, objects, attributes, relationships",
        "Return detected objects with confidence scores and bounding boxes (if available)",
        "Produce scene-level summary and per-image structured output",
        "Highlight safety/NSFW concerns and any text detected via OCR"
      ],
      "input_schema": {
        "system_prompt": {
          "type": "string",
          "required": true,
          "description": "System instruction for the Gemini model (defines role/response format). Example: 'You are an assistant that returns JSON with keys summary, detected_objects, per_image_analysis'"
        },
        "user_query": {
          "type": "string",
          "required": true,
          "description": "User's query / instruction describing what to analyze or extract from the images"
        },
        "image_urls": {
          "type": "array",
          "required": true,
          "description": "List of publicly accessible image URLs to analyze"
        },
        "model_name": {
          "type": "string",
          "required": false,
          "description": "Gemini model to use (default: 'gemini-2.5-flash')"
        }
      }
    },
    "analyze_video": {
      "tool_description": "Analyze a single video URL with Gemini multimodal model and return structured JSON analysis including timestamps of key events.",
      "capabilities": [
        "Summarize the video, list detected objects and actions, return timestamped key events and shot boundaries",
        "Detect repeated patterns, safety issues, or textual overlays (OCR)",
        "Provide scene-level descriptions and an ordered timeline of notable moments"
      ],
      "input_schema": {
        "system_prompt": {
          "type": "string",
          "required": true,
          "description": "System instruction for the Gemini model (defines role/response format). Example: 'You are an assistant that returns JSON with keys summary, timeline, detected_objects'"
        },
        "user_query": {
          "type": "string",
          "required": true,
          "description": "User's query / instruction describing what to analyze or extract from the video"
        },
        "video_url": {
          "type": "string",
          "required": true,
          "description": "Publicly accessible URL of the video to analyze (single URL)"
        },
        "model_name": {
          "type": "string",
          "required": false,
          "description": "Gemini model to use (default: 'gemini-2.5-pro')"
        }
      }
    },
    "unified_search": {
      "tool_description": "Unified search across multiple social media platforms (Instagram, YouTube, Reddit) with configurable parameters.",
      "capabilities": [
        "Search Instagram posts using Apify API (hashtags, username, etc.)",
        "Search YouTube videos using official API with date filters",
        "Search Reddit posts across all subreddits using PRAW",
        "Return structured results with metadata and platform-specific information",
        "Didn't have support for LinkedIn and Twitter"
      ],
      "input_schema": {
        "platform": {
          "type": "string",
          "required": true,
          "description": "Platform to search: 'instagram', 'youtube', or 'reddit'"
        },
        "query": {
          "type": "string",
          "required": true,
          "description": "Search query string"
        },
        "limit": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of results to fetch (default: 10)"
        },
        "days_back": {
          "type": "integer",
          "required": false,
          "description": "Number of days to look back for content (YouTube, Reddit)"
        },
        "search_type": {
          "type": "string",
          "required": false,
          "description": "Type of search for Instagram: 'hashtag' or 'user' (default: 'hashtag')"
        }
      }
    },
    "get_media": {
      "tool_description": "Download media content (videos, images) with metadata from supported platforms (YouTube, Instagram, LinkedIn).",
      "capabilities": [
        "Download videos and images from YouTube, Instagram, and LinkedIn",
        "Extract metadata including captions, likes, comments, published dates",
        "Return structured results with file paths, metadata, and Cloudinary URLs"
      ],
      "input_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "URL of the media content to download (YouTube, Instagram, LinkedIn)"
        },
        "upload_to_cloudinary_flag": {
          "type": "boolean",
          "required": false,
          "description": "Whether to upload downloaded media to Cloudinary (default: True)"
        },
        "custom_config": {
          "type": "object",
          "required": false,
          "description": "Optional custom configuration to override defaults"
        }
      }
    },
    "kie_image_generation": {
      "tool_description": "Generate or edit high-quality images using KIE API with advanced prompt enhancement and reference image comparison.",
      "capabilities": [
        "Generate images from text prompts with artistic enhancement",
        "Compare or edit generated images with reference images",
        "Provide improvement suggestions based on similarity analysis",
        "Handle multiple image formats and sizes"
      ],
      "input_schema": {
        "prompt": {
          "type": "string",
          "required": true,
          "description": "Enhanced text prompt for image generation (will be automatically enhanced with artistic details)"
        },
        "reference_image_url": {
          "type": "string",
          "required": false,
          "description": "Optional reference image URL for comparison and improvement suggestions"
        },
        "model": {
          "type": "string",
          "required": false,
          "description": "KIE model to use (default: 'google/nano-banana-edit')"
        },
        "image_size": {
          "type": "string",
          "required": false,
          "description": "Image size ratio (default: '1:1')"
        },
        "style_preferences": {
          "type": "object",
          "required": false,
          "description": "Style preferences including style, mood, and color_scheme"
        }
      }
    },
    "gemini_audio": {
      "tool_description": "Generate high-quality audio from text using Gemini TTS with voice enhancement and emotional context.",
      "capabilities": [
        "Convert text to speech with natural voice synthesis",
        "Enhance text with emotional context and voice instructions",
        "Support multiple voice options (Kore, Aoede, Charon, Fenrir, Puck, etc.)",
        "Handle various audio formats and quality settings"
      ],
      "input_schema": {
        "text": {
          "type": "string",
          "required": true,
          "description": "Text to convert to speech (will be enhanced with voice instructions if needed)"
        },
        "voice_name": {
          "type": "string",
          "required": false,
          "description": "Voice to use (default: 'Kore', options: 'Kore', 'Aoede', 'Charon', 'Fenrir', 'Puck')"
        },
        "voice_style": {
          "type": "string",
          "required": false,
          "description": "Voice style enhancement (e.g., 'cheerful', 'serious', 'energetic')"
        }
      }
    },
    "minimax_audio_clone": {
      "tool_description": "Generate voice clones using Minimax AI technology with advanced voice synthesis capabilities.",
      "capabilities": [
        "Create voice clones from sample audio",
        "Generate speech in cloned voice with high fidelity",
        "Handle various audio formats and quality settings",
        "Provide detailed voice cloning metadata"
      ],
      "input_schema": {
        "text": {
          "type": "string",
          "required": true,
          "description": "Text to generate in cloned voice"
        },
        "voice_sample_url": {
          "type": "string",
          "required": true,
          "description": "URL of voice sample for cloning"
        },
        "voice_id": {
          "type": "string",
          "required": false,
          "description": "Optional voice ID for existing cloned voice"
        },
        "quality": {
          "type": "string",
          "required": false,
          "description": "Audio quality setting (default: 'high')"
        }
      }
    },
    "microsoft_tts": {
      "tool_description": "Microsoft Text-to-Speech service as fallback for audio generation with neural voices support.",
      "capabilities": [
        "High-quality neural voice synthesis",
        "Multiple language and voice options",
        "Fallback option when Gemini TTS is unavailable",
        "Support for SSML markup for advanced speech control"
      ],
      "input_schema": {
        "text": {
          "type": "string",
          "required": true,
          "description": "Text to convert to speech"
        },
        "voice_name": {
          "type": "string",
          "required": false,
          "description": "Voice name (default: 'en-US-JennyNeural')"
        },
        "style": {
          "type": "string",
          "required": false,
          "description": "Voice style (e.g., 'cheerful', 'sad', 'angry')"
        }
      }
    },
    "verification_tool": {
      "tool_description": "Comprehensive error diagnosis and solution generation for agent/tool execution failures. Analyzes failed executions and provides root cause analysis, prioritized remediation actions, and automated fix suggestions.",
      "capabilities": [
        "Diagnose agent/tool execution failures with confidence scores",
        "Identify root causes including schema mismatches, capability gaps, and prompt issues",
        "Provide prioritized remediation actions (auto_fix_and_retry, retry_with_prompt_fix, correct_input_schema, etc.)",
        "Generate automated fix suggestions with JSON patches",
        "Recommend alternative agents/tools when capability mismatches occur",
        "Detect safety issues and provide warnings for sensitive operations",
        "Analyze error codes (401, 403, 429, 500) and provide specific remediation",
        "Validate input schemas and suggest corrections",
        "Identify when wrong agents are routed and suggest better alternatives"
      ],
      "input_schema": {
        "planner_step": {
          "type": "object",
          "required": false,
          "description": "The orchestrator step/agent step that invoked the agent/tool"
        },
        "agent_name": {
          "type": "string",
          "required": false,
          "description": "Name of the agent that failed"
        },
        "agent_capabilities": {
          "type": "array",
          "required": false,
          "description": "Capabilities of the agent (list or object)"
        },
        "tool_name": {
          "type": "string",
          "required": false,
          "description": "Name of the tool that failed"
        },
        "tool_input_schema": {
          "type": "object",
          "required": false,
          "description": "Expected input schema for the tool"
        },
        "tool_capabilities": {
          "type": "object",
          "required": false,
          "description": "Capabilities of the tool"
        },
        "agent_query": {
          "type": "string",
          "required": false,
          "description": "The prompt/arguments the agent sent"
        },
        "tool_call_payload": {
          "type": "object",
          "required": false,
          "description": "The exact JSON/args sent to the tool"
        },
        "tool_response": {
          "type": "object",
          "required": false,
          "description": "What the tool returned (success or error)"
        },
        "error_details": {
          "type": "object",
          "required": false,
          "description": "Stack trace, error code, status, latency, retries"
        },
        "agent_output": {
          "type": "object",
          "required": false,
          "description": "What the agent produced as output"
        },
        "agent_context": {
          "type": "array",
          "required": false,
          "description": "Short chronological log lines"
        },
        "previous_attempts": {
          "type": "array",
          "required": false,
          "description": "Prior attempts and fixes tried"
        },
        "available_agents": {
          "type": "array",
          "required": false,
          "description": "List of available agents for routing suggestions"
        },
        "available_tools": {
          "type": "array",
          "required": false,
          "description": "List of available tools for fallback suggestions"
        }
      }
    }
  }
}